<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "https://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="kr.co.fitzcode.admin.mapper.InquiryMapper">

    <!-- 전체 문의 개수 조회 -->
    <select id="getTotalInquiryCount" resultType="int">
        SELECT COUNT(*) FROM INQUIRY;
    </select>

    <!-- 전체 문의 목록 조회 -->
    <select id="getInquiryList" resultType="InquiryDTO">
        SELECT i.inquiry_id, i.user_id, u.user_name, i.order_id, i.subject, i.content,
        i.category AS categoryCode, i.status AS statusCode, i.reply, i.created_at, i.updated_at
        FROM INQUIRY i
        JOIN USER u ON i.user_id = u.user_id
        ORDER BY i.created_at DESC
        LIMIT #{limit} OFFSET #{offset}
    </select>

    <!-- 문의 상세 조회 -->
    <select id="getInquiryDetail" resultType="InquiryDTO">
        SELECT i.inquiry_id, i.user_id, u.user_name, i.order_id, i.subject, i.content,
        i.category AS categoryCode, i.status AS statusCode, i.reply, i.created_at, i.updated_at
        FROM INQUIRY i
        JOIN USER u ON i.user_id = u.user_id
        WHERE i.inquiry_id = #{inquiryId}
    </select>

    <!-- 문의 상태 변경 -->
    <update id="updateInquiryStatus">
        UPDATE INQUIRY SET status = #{status}, updated_at = NOW()
        WHERE inquiry_id = #{inquiryId}
    </update>

    <!-- 문의 카테고리 추가 및 수정 -->
    <update id="updateInquiryCategory">
        UPDATE INQUIRY SET category = #{category}, updated_at = NOW()
        WHERE inquiry_id = #{inquiryId}
    </update>

    <!-- 답변 -->
    <update id="updateInquiryReplyAndStatus">
        UPDATE INQUIRY
        SET reply = #{reply}, status = #{status}, updated_at = NOW()
        WHERE inquiry_id = #{inquiryId}
    </update>

    <!--
    1:1 문의 목록을 필터링하여 반환하는 쿼리
    - 카테고리 필터 (categoryIds)와 상태 필터 (statusCodes)가 전달될 경우 해당 조건에 맞는 결과를 조회
    - 조회된 문의 리스트는 생성일(created_at)을 기준으로 내림차순 정렬되고 페이징 처리하려고 LIMIT OFFSET 적용했음
    -->
    <select id="getFilteredInquiryList" resultType="InquiryDTO">
        SELECT i.inquiry_id, i.user_id, u.user_name, i.order_id, i.subject, i.content,
        i.category AS categoryCode, i.status AS statusCode, i.reply, i.created_at, i.updated_at
        FROM INQUIRY i
        JOIN USER u ON i.user_id = u.user_id
        <where>
            <if test="categoryIds != null and !categoryIds.isEmpty()">
                AND i.category IN
                <foreach collection="categoryIds" item="categoryId" open="(" close=")" separator=",">
                    #{categoryId}
                </foreach>
            </if>
            <if test="statusCodes != null and !statusCodes.isEmpty()">
                AND i.status IN
                <foreach collection="statusCodes" item="statusCode" open="(" close=")" separator=",">
                    #{statusCode}
                </foreach>
            </if>
        </where>
        ORDER BY i.created_at DESC
        LIMIT #{limit} OFFSET #{offset}
    </select>

    <!--
    1:1 문의의 전체 개수를 필터링 조건에 맞춰 반환함
    카테고리 필터(categoryIds)와 상태 필터(statusCodes)가 전달되면 해당 필터 조건을 기반으로 총 개수를 구함
    -->
    <select id="getTotalFilteredInquiryCount" resultType="int">
        SELECT COUNT(*)
        FROM INQUIRY i
        <where>
            <if test="categoryIds != null and !categoryIds.isEmpty()">
                AND i.category IN
                <foreach collection="categoryIds" item="categoryId" open="(" close=")" separator=",">
                    #{categoryId}
                </foreach>
            </if>
            <if test="statusCodes != null and !statusCodes.isEmpty()">
                AND i.status IN
                <foreach collection="statusCodes" item="statusCode" open="(" close=")" separator=",">
                    #{statusCode}
                </foreach>
            </if>
        </where>
    </select>

</mapper>